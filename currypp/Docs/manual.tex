\section{CurryPP: A Preprocessor for Curry Programs}

The Curry preprocessor \ccode{currypp}
\index{Curry preprocessor}\index{preprocessor}
implements
various transformations on Curry source programs.
It supports some experimental language extensions
that might become part of the standard parser of Curry
in some future version.

Currently, the Curry preprocessor
supports the following extensions that will be described below in more detail:

\begin{description}
\item[Integrated code:]
This extension allows to integrate
code written in some other language into Curry programs,
like regular expressions, format specifications (\ccode{printf}),
HTML and XML code.
\item[Sequential rules:]
If this feature is used, all rules in a Curry module are
interpreted as sequential, i.e., a rule is applied only
if all previous rules defining the same operation are not applicable.
The idea of sequential rules are described in \cite{AntoyHanus14}.
\item[Default rules:]
If this feature is used, one can add a default rule
to operations defined in a Curry module.
This provides a similar power than sequential rules
but with a better operational behavior.
The idea of default rules are described in \cite{AntoyHanus16PADL}.
\end{description}
%
The preprocessor is an executable named \ccode{currypp},
which is stored in the directory \code{\cyshome/bin}.
In order to apply the preprocessor when loading a Curry source
program into \CYS, one has to add an option line
at the beginning of the source program.
For instance, in order to use default rules in a Curry program,
one has to put the line
\begin{curry}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=defaultrules #-}
\end{curry}
at the beginning of the program.
This option tells the \CYS front end to process the Curry source program
with \code{currypp} before actually parsing the source text.

The option \ccode{defaultrules} has to be replaced by
\ccode{seqrules} if the sequential rule matching should be replaced.
To support integrated code, one has to set the option
\ccode{foreigncode} (which can also be combined with
either \ccode{defaultrules} or \ccode{seqrules}.
If one wants to see the result of the transformation, one can
also set the option \ccode{-o}. This has the effect that the
transformed source program is stored in the file
\code{Prog.curry.CURRYPP} if the name of the original program
is \code{Prog.curry}.

For instance, in order to use integrated code and default rules
in a module and store the transformed program,
one has to put the line
\begin{curry}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=foreigncode --optF=defaultrules --optF=-o #-}
\end{curry}
at the beginning of the program.


\subsection{Integrated Code}

Integrated code is enclosed in at least two back ticks and ticks
in a Curry program. The number of starting back ticks and ending ticks
must be always identical.
After the initial back ticks, there must be an identifier
specifying the kind of integrated code,
e.g., \code{regexp} or \code{html} (see below).
For instance, if one uses regular expressions (see below for more details),
the following expressions are valid in source programs:
\begin{curry}
  s ``regex (a|(bc*))+''
  s ````regex aba*c''''
\end{curry}
The Curry preprocessor transforms these code pieces into regular
Curry expressions. The next sections describe the currently
supported foreign languages.


\subsubsection{Regular Expressions}

In order to match strings against regular expressions, i.e.,
to check whether a string is contained in the language
generated by a regular expression, one can specify
regular expression similar to POSIX. The foreign regular
expression code must be marked by \ccode{regexp}.
Since this code is transformed into operations of the \CYS library
\code{RegExp}, this library must be imported.

For instance, the following module defines a predicate
to check whether a string is a valid identifier:

\begin{curry}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=foreigncode #-}

import RegExp

isID :: String -> Bool
isID s = s ``regex [a-zA-Z][a-zA-Z0-9_']*''
\end{curry}


\subsubsection{Format Specifications}

In order to format numerical and other data as strings,
one can specify the desired format with foreign code marked by
\ccode{format}. In this case, one can write a format specification,
similarly to the \code{printf} statement of C,
followed by a comma-separated list of arguments.
This format specification is transformed into operations
of the \CYS library \code{Format} so that it must be imported.
For instance, the following program defines an operation
that formats a string, an integer (with leading sign and zeros),
and a float with leading sign and precision 3:
\begin{currynomath}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=foreigncode #-}

import Format

showSIF :: String -> Int -> Float -> String
showSIF s i f = ``format "Name: %s | %+.5i | %+6.3f",s,i,f''

main = putStrLn $ showSIF "Curry" 42 3.14159
\end{currynomath} % $
Thus, the execution of \code{main} will print the line
\begin{curry}
Name: Curry | +00042 | +3.142
\end{curry}

Instead of \ccode{format}, one can also write a format specification
with \code{printf}. In this case, the formatted string is
printed with \code{putStr}. Hence, we can rewrite our previous definitions
as follows:
\begin{curry}
showSIF :: String -> Int -> Float -> IO ()
showSIF s i f = ``printf "Name: %s | %+.5i | %+6.3f\n",s,i,f''

main = showSIF "Curry" 42 3.14159
\end{curry}


\subsubsection{HTML Code}

The foreign language tag \ccode{html} introduces a notation
for HTML expressions (see \CYS library \code{HTML})
with the standard HTML syntax extended by a layout rule
so that closing tags can be omitted.
In order to include strings computed by Curry expressions
into these HTML syntax, these Curry expressions must be enclosed
in curly brackets.
The following example program shows its use:
\begin{curry}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=foreigncode #-}

import HTML

htmlPage :: String -> [HtmlExp]
htmlPage name = ``html
 <html>

  <head>
   <title>Simple Test

  <body>
   <h1>Hello {name}!</h1>
    <p>
     Bye!
    <p>Bye!
   <h2>{reverse name}
   Bye!''
\end{curry}
%
If a Curry expression computes an HTML expression,
i.e., it is of type \code{HtmlExp} instead of \code{String},
it can be integrated into the HTML syntax by double curly brackets.
The following simple example, taken from \cite{Hanus01PADL},
shows the use of this feature:

\begin{currynomath}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=foreigncode #-}

import HTML

main :: IO HtmlForm
main = return $ form "Question" $
         ``html
	     Enter a string: {{textfield tref ""}}
	     <hr>
             {{button "Reverse string"   revhandler}}
             {{button "Duplicate string" duphandler}}''

 where
  tref free

  revhandler env = return $ form "Answer"
    ``html <h1>Reversed input: {reverse (env tref)}''

  duphandler env = return $ form "Answer"
    ``html
       <h1>
         Duplicated input:
         {env tref ++ env tref}''
\end{currynomath}


\subsubsection{XML Expressions}

The foreign language tag \ccode{xml} introduces a notation
for XML expressions (see \CYS library \code{XML}).
The syntax is similar to the language tag \ccode{html},
i.e., the use of the layout rule avoids closing tags
and Curry expressions evaluating to strings (\code{String})
and XML expressions (\code{XmlExp}) can be included by enclosing
them in curly and double curly brackets, respectively.
The following example program shows its use:
\begin{currynomath}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=foreigncode #-}

import HTML

import XML

main :: IO ()
main = putStrLn $ showXmlDoc $ head ``xml
 <contact>
  <entry>
   <phone>+49-431-8807271
   <name>Hanus
   <first>Michael
   <email>mh@informatik.uni-kiel.de
   <email>hanus@email.uni-kiel.de
   
  <entry>
   <name>Smith
   <first>Bill
   <phone>+1-987-742-9388
 ''
\end{currynomath}


\subsection{Sequential Rules}

If the Curry preprocessor is called with the option
\ccode{seqrules}, then all rules in the Curry module are
interpreted in a sequential manner, i.e., a rule is applied only
if all previous rules defining the same operation are not applicable,
either because the left-hand side's pattern does not match
or the condition is not satisfiable.
The idea and detailed semantics of
sequential rules are described in \cite{AntoyHanus14}.
Sequential rules are useful and preferable over
rules with multiple guards if the patterns are non-trivial
(e.g., functional patterns) or the condition involve complex
constraints.

As a simple example, the following module defines
a lookup operation in association lists by a functional pattern.
Due to the sequential rule strategy,
the second rule is applied only if there is no appropriate
key in the association list:
%
\begin{curry}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=seqrules #-}

mlookup key (_ ++ [(key,value)] ++ _) = Just value
mlookup _   _                         = Nothing 
\end{curry}


\subsection{Default Rules}

An alternative to sequential rules are default rules, i.e.,
these two options cannot be simultaneously used.
Default rules are activated by the preprocessor option
\ccode{defaultrules}.
In this case, one can add to each operation a default rule.
A default rule for a function $f$ is defined as a rule
defining the operation \ccode{$f$'default} (this mechanism
avoids any language extension for default rules).
A default rule is applied only if no ``standard'' rule is
applicable, either because the left-hand sides' pattern do not match
or the conditions are not satisfiable.

Default rules are preferable over the sequential rule selection
strategy since they have a better operational behavior.
This is due to the fact that the test for the application
of default rules is done with the same (sometimes optimal)
strategy than the selection of standard rules.
Moreover, default rules provide a similar power than sequential rules,
i.e., they can be applied if the standard rules have
complex (functional) patterns or complex conditions.

As a simple example, we show the implementation of the
previous example for sequential rules with a default rule:
%
\begin{curry}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=defaultrules #-}

mlookup key (_ ++ [(key,value)] ++ _) = Just value
mlookup'default _   _                 = Nothing 
\end{curry}
%
Default rules are often a good replacement for ``negation as failure''
used in logic programming.
For instance, the following program defines a solution
to the $n$-queens puzzle, where the default rule is useful
since it is easier to characterize the unsafe positions
of the queens on the chessboard (see the first rule of \code{safe}):
%
\begin{curry}
{-# OPTIONS_CYMAKE -F --pgmF=currypp --optF=defaultrules #-}

import Combinatorial(permute)
import Integer(abs)

-- A placement is safe if two queens are not in a same diagonal:
safe (_++[x]++ys++[z]++_) | abs (x-z) == length ys + 1 = failed
safe'default xs = xs

-- A solution to the n-queens puzzle is a safe permutation:
queens :: Int -> [Int]
queens n = safe (permute [1..n])
\end{curry}

%  LocalWords:  preprocessor
